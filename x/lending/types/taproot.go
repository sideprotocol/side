package types

import (
	"encoding/hex"
	"fmt"

	h2c "github.com/bytemare/hash2curve/secp256k1"
	"github.com/decred/dcrd/dcrec/secp256k1/v4"

	"github.com/btcsuite/btcd/btcec/v2"
	"github.com/btcsuite/btcd/btcec/v2/schnorr"
	"github.com/btcsuite/btcd/btcutil"
	"github.com/btcsuite/btcd/btcutil/psbt"
	"github.com/btcsuite/btcd/chaincfg"
	"github.com/btcsuite/btcd/txscript"

	"github.com/sideprotocol/side/bitcoin"
	"github.com/sideprotocol/side/crypto/adaptor"
	"github.com/sideprotocol/side/crypto/hash"
	"github.com/sideprotocol/side/x/dlc/types"
)

// HashLoanSecret hashes the given secret
// Assume that the secret is a valid hex string
func HashLoanSecret(secret string) string {
	secretBytes, _ := hex.DecodeString(secret)

	return hex.EncodeToString(hash.Sha256(secretBytes))
}

// AdaptorPoint gets the corresponding adaptor point from the given secret
func AdaptorPoint(secret []byte) string {
	return hex.EncodeToString(adaptor.SecretToPubKey(secret))
}

// Branch 1: multisig signature script
func CreateMultisigScript(pubKeys []string) ([]byte, error) {
	builder := txscript.NewScriptBuilder()
	for i, pubKeyHex := range pubKeys {
		pubKey, err := hex.DecodeString(pubKeyHex)
		if err != nil {
			return nil, err
		}

		builder.AddData(pubKey)

		if i == 0 {
			builder.AddOp(txscript.OP_CHECKSIG)
		} else {
			builder.AddOp(txscript.OP_CHECKSIGADD)
		}
	}

	builder.AddInt64(int64(len(pubKeys)))
	builder.AddOp(txscript.OP_NUMEQUAL)

	return builder.Script()
}

// Branch 2: Hash Time lock script for DCA
func CreateHashTimeLockScript(pubKey string, hashLock string, lockTime int64) ([]byte, error) {
	pubKeyBytes, err := hex.DecodeString(pubKey)
	if err != nil {
		return nil, err
	}

	hashLockBytes, err := hex.DecodeString(hashLock)
	if err != nil {
		return nil, err
	}

	builder := txscript.NewScriptBuilder()
	builder.AddInt64(lockTime)                     // Add lock time
	builder.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY) // Enforce time lock
	builder.AddOp(txscript.OP_DROP)                // Drop locktime from the stack
	builder.AddOp(txscript.OP_SHA256)              // Add hash lock
	builder.AddData(hashLockBytes)                 // Push hash lock
	builder.AddOp(txscript.OP_EQUALVERIFY)         // Verify hash preimage
	builder.AddData(pubKeyBytes)                   // Push pubkey
	builder.AddOp(txscript.OP_CHECKSIG)            // Verify signature

	return builder.Script()
}

// Branch 3: PubKey with Time lock script
func CreatePubKeyTimeLockScript(pubKeyHex string, lockTime int64) ([]byte, error) {
	pubKey, err := hex.DecodeString(pubKeyHex)
	if err != nil {
		return nil, err
	}

	builder := txscript.NewScriptBuilder()
	builder.AddInt64(lockTime)
	builder.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY)
	builder.AddOp(txscript.OP_DROP)
	builder.AddData(pubKey)
	builder.AddOp(txscript.OP_CHECKSIG)

	return builder.Script()
}

// Create Taproot address with complex script branches
func CreateTaprootAddress(internalKey *secp256k1.PublicKey, branches [][]byte, params *chaincfg.Params) (string, error) {
	tapScriptTree := GetTapscriptTree(branches)
	scriptRoot := tapScriptTree.RootNode.TapHash()

	taprootOutKey := txscript.ComputeTaprootOutputKey(internalKey, scriptRoot[:])

	// Generate Taproot address
	address, err := btcutil.NewAddressTaproot(schnorr.SerializePubKey(taprootOutKey), params)
	if err != nil {
		return "", err
	}

	return address.EncodeAddress(), nil
}

func CreateVaultAddress(borrowerPubkey string, dcaPubkey string, loanSecretHash string, muturityTime int64, finalTimeout int64) (string, error) {
	params := bitcoin.Network

	// multisig script for liquidation cet and repayment
	multisigScript, err := CreateMultisigScript([]string{borrowerPubkey, dcaPubkey})
	if err != nil {
		return "", err
	}

	forcedRepaymentScript, err := CreateHashTimeLockScript(dcaPubkey, loanSecretHash, muturityTime)
	if err != nil {
		return "", err
	}

	timeoutRefundScript, err := CreatePubKeyTimeLockScript(borrowerPubkey, finalTimeout)
	if err != nil {
		return "", err
	}

	// Combine branches
	branches := [][]byte{multisigScript, forcedRepaymentScript, timeoutRefundScript}

	// Generate Taproot address
	taprootAddress, err := CreateTaprootAddress(GetInternalKey(), branches, params)
	if err != nil {
		return "", err
	}

	return taprootAddress, nil
}

// GetInternalKey gets the pub key used for taproot address generation
// Generated by hashToCurve("lending") for now
func GetInternalKey() *btcec.PublicKey {
	input := types.ModuleName
	domain := "side.lending.vault"

	p := h2c.HashToCurve([]byte(input), []byte(domain))

	var X, Y btcec.FieldVal
	X.SetByteSlice(p.X.Bytes())
	Y.SetByteSlice(p.Y.Bytes())

	return btcec.NewPublicKey(&X, &Y)
}

func GetTapscriptTree(scripts [][]byte) *txscript.IndexedTapScriptTree {
	leaves := []txscript.TapLeaf{}

	for _, script := range scripts {
		leaves = append(leaves, txscript.NewBaseTapLeaf(script))
	}

	tree := txscript.AssembleTaprootScriptTree(leaves...)

	return tree
}

func GetControlBlock(pubKey *secp256k1.PublicKey, proof txscript.TapscriptProof) ([]byte, error) {
	controlBlock := proof.ToControlBlock(pubKey)

	controlBlockBz, err := controlBlock.ToBytes()
	if err != nil {
		return nil, err
	}

	return controlBlockBz, nil
}

// CalcTapscriptSigHash computes the sig hash of the given script
// Assume that the psbt is valid
func CalcTapscriptSigHash(p *psbt.Packet, idx int, sigHashType txscript.SigHashType, script []byte) ([]byte, error) {
	prevOutFetcher := txscript.NewMultiPrevOutFetcher(nil)
	for i, txIn := range p.UnsignedTx.TxIn {
		prevOutFetcher.AddPrevOut(txIn.PreviousOutPoint, p.Inputs[i].WitnessUtxo)
	}

	sigHash, err := txscript.CalcTapscriptSignaturehash(txscript.NewTxSigHashes(p.UnsignedTx, prevOutFetcher), sigHashType, p.UnsignedTx, idx, prevOutFetcher, txscript.NewBaseTapLeaf(script))
	if err != nil {
		return nil, err
	}

	return sigHash, nil
}

// GetPkScriptFromAddress gets the pk script of the given address
func GetPkScriptFromAddress(address string) ([]byte, error) {
	addr, err := btcutil.DecodeAddress(address, bitcoin.Network)
	if err != nil {
		return nil, err
	}

	return txscript.PayToAddrScript(addr)
}

// GetPkScriptFromPubKey gets the pk script from the given agency pubkey
// Assume that the given pubkey is 32 bytes w/o 0x prefix
func GetPkScriptFromPubKey(pubKeyHex string) ([]byte, error) {
	pubKey, err := hex.DecodeString(fmt.Sprintf("02%s", pubKeyHex))
	if err != nil {
		return nil, err
	}

	parsedPubKey, err := secp256k1.ParsePubKey(pubKey)
	if err != nil {
		return nil, err
	}

	taprootOutKey := txscript.ComputeTaprootKeyNoScript(parsedPubKey)

	return txscript.PayToTaprootScript(taprootOutKey)
}
